#include "Arduino.h"
#include <LibAPRS.h>
#include <TinyGPS++.h>
#include <OneWire.h>
#include <DallasTemperature.h>

// kas kiek laiko (sekundemis) siusim pozicijos paketa
#define PACKET_INTERVAL 60
#define TELEMETRY_PACKET_INTERVAL 30

//The setup function is called once at startup of the sketch
// 3V3 arba 5V, mes naudojam 3.3V. Kadangi nenaudojam RX, tai sitas nera svarbu
#define ADC_REFERENCE REF_3V3
#define SERIAL_BAUDRATE 9600	// GPS modulis nusiresetina i sita greiti, tai taip ir paliekam

// LY3FF-1
#define APRS_CALLSIGN "LY3FF"
#define APRS_SSID     15

// saukinys 9 baitu ilgio formate telemetrijos paketu generavimui, bus irasyta i progmem
#define APRS_TELEMETRY_CALL "LY3FF-15 "
//                           123456789
// milisekundemis
#define DELAY_AFTER_PTT_ON 500
#define APRS_PREAMBLE 550

#define OPEN_SQUELCH false
#define PTT_PIN 11

// Temperaturos davikliai ant sios kojos
#define ONE_WIRE_BUS 12

#define ON LOW
#define OFF HIGH

#define VERSION_NUMBER "0.1b"
#define VERSION VERSION_NUMBER " "  __DATE__

	const PROGMEM char TELEMETRY_PARAM_NAMES[] = ":" APRS_TELEMETRY_CALL ":PARM.Battery,ITemp,OTemp";
	const PROGMEM char TELEMETRY_PARAM_UNITS[] = ":" APRS_TELEMETRY_CALL ":UNIT.V/100,deg.C,deg.C";
	// TODO: update equations
//	const PROGMEM char TELEMETRY_PARAM_EQUATIONS[] = ":" APRS_TELEMETRY_CALL ":EQNS.0,5.2,0,0,0,.53,-32,3,4.39,49,-32,3,18,1,2,3" ;
	const PROGMEM char TELEMETRY_PARAM_EQUATIONS[] = ":" APRS_TELEMETRY_CALL ":EQNS.0,5.2,0,0,0,-55,0,0,-55" ;

class APRSTelemetry{
	// KISS -- Keep It Simple Stupid
	/*
	 * Analog channel 1 - Battery Voltage
	 * Analog channel 2 - Inside temperature
	 * Analog channel 3 - Outside temperature
	 *
	 * 8 digital channels
	 *
	 * every digital channel is set as literal 1 or 0 directly in bits[8] char array.
	 * Later we just add this array to the telemetry packet end
	 *
	 * Note: Again, the field widths are not all the same, and the byte counts include the comma separators
	 * where shown. The list can terminate after any field.
	*/

# define VOLTAGE_ADC_PIN (char) A2
# define MB_DIVIDER_R1  10000
# define MB_DIVIDER_R2  10000
/*
 * Max reported voltage - 6.4 V, see scripts/battery.pl
 */

/*
 * ADC (Vcc/maitinimo) itampa, cia reikia nurodyti kuo tikslesne, kad baterijos itampos matavimai butu
 * kuo tikslesni. 5.2f
 */
# define MB_ADC_VOLTAGE 3.2f
//#define MB_MAX_VOLTAGE ((MB_DIVIDER_R1 + MB_DIVIDER_R2) * MB_ADC_VOLTAGE) / MB_DIVIDER_R2
	const double _mbMaxVoltage = (((double) MB_DIVIDER_R1 + (double) MB_DIVIDER_R2) * (double) MB_ADC_VOLTAGE) / (double) MB_DIVIDER_R2;
	// 	Vs	 = ((R1 + R2) * Vs) / R2

	private:
	unsigned char _sequence_number = 0;
	unsigned char _temperature[2] = { 0, 0 };	// generated temperature bytes for telemetry out.
	unsigned char _t_voltage = 0;				// generated byte for telemetry output

	double _battery_voltage=0;			// actual battery voltage
	unsigned char _packet_to_send   = 0;	// which packet will be sent next (units, params, eqns)
	unsigned int _ts_packet_to_send = 0;
	unsigned int _ts_read_sensors = 0; //
	unsigned int _ts_telemetry_packet = 0;

	OneWire *_oneWire;
	DallasTemperature *_sensors;

	public:
	char _packet_buffer[80];
	int _packet_length = 0;
	char _bits[9] = { '0', '0', '0', '0', '0', '0', '0', '0', 0 };

//	const char TELEMETRY_PARAM_NAMES[] = ":" APRS_TELEMETRY_CALL ":PARM.Battery,ITemp,OTemp";
//	const char TELEMETRY_PARAM_UNITS[] = ":" APRS_TELEMETRY_CALL ":UNIT.V/100,deg.C,deg.C";
	// TODO: update equations
//	const PROGMEM char TELEMETRY_PARAM_EQUATIONS[] = ":" APRS_TELEMETRY_CALL ":EQNS.0,5.2,0,0,0,.53,-32,3,4.39,49,-32,3,18,1,2,3" ;
//	const char TELEMETRY_PARAM_EQUATIONS[] = ":" APRS_TELEMETRY_CALL ":EQNS.0,5.2,0,0,0,-55,0,0,-55" ;

	const char *_tpn = TELEMETRY_PARAM_NAMES;
	const char *_tpu = TELEMETRY_PARAM_UNITS;
	const char *_tpe = TELEMETRY_PARAM_EQUATIONS;

	/*
	 *
	 * five channels in sets of 3
	 * a * v**2 + b * v + c
	 *
	 * here we define equation coeficients how to use our data.
	 * Channel 1
	 * a = 0, b = 5.2, c = 0
	 * Channel 2
	 * a = 0, b = 0,   c = -55
	 * Channel 3
	 * a = 0, b = 0,   c = -55
	 * Channels 4 & 5 are not used, so we terminate after 3 channels
	 */

	void updateBatteryVoltage(){
		//TODO: nustatyti itampos kanalo baita pagal lygti
		// (int) (4.2 * 100) / 5,2 = 80
		this->_t_voltage =  (_battery_voltage * 100) / 5.2;

	}

	void updateTemperatures(int temp1, int temp2){
		// reported temp = temp + 55, receiving end should use equations packet to decode.
		this->_temperature[0] = temp1+55;
		this->_temperature[1] = temp2+55;
	}

	void generateTelemetryPacket(){
		/*
		 * suraso telemetrijos paketa i packet_buffer. nurodo paketo ilgi i packet_length
		 */
		// T#MIC199,000,255,073,123,01101001   -- 33 bytes
//		packet_length = sprintf_P(packet_buffer, PSTR("aaa"),0);
		_packet_length = sprintf_P(_packet_buffer, PSTR("T#%03u,%03u,%03u,%03u,%03u,%03u,"),
				this->_sequence_number, this->_t_voltage, this->_temperature[0], this->_temperature[1], 0, 0);
		strncat(&_packet_buffer[_packet_length],_bits, 8);
		_packet_length +=8;
		this->_sequence_number++;

	}

	void generateParametersPacket(){
		Serial.println(F("Generating parameters packet"));
//		strcpy_P(packet_buffer, TELEMETRY_PARAM_NAMES)	}
//		packet_length = sizeof(TELEMETRY_PARAM_NAMES);
		_packet_length = strlen_P(_tpn);
		strncpy_P(_packet_buffer, _tpn, _packet_length);
//		_packet_buffer[_packet_length] = 0;	// null termination

	}

	void generateUnitsPacket(){
		//generate unit description packet
		Serial.println(F("Generating units packet"));
//		packet_length = sizeof(TELEMETRY_PARAM_UNITS);
		_packet_length = strlen_P(_tpu);
		strncpy_P(_packet_buffer, _tpu, _packet_length);
//		_packet_buffer[_packet_length] = 0;	// null termination
	}

	void generateEQNSPacket(){
		// generate equations packet
		Serial.println(F("Generating equations packet"));
//		packet_length = sizeof(TELEMETRY_PARAM_EQUATIONS);
		_packet_length = strlen_P(_tpe);
		strncpy_P(_packet_buffer, _tpe, _packet_length);
//		_packet_buffer[_packet_length] = 0;	// null termination
	}

	void sendTelemetryPacket(){
		// this sends already generated packet
		setPTT(ON);
		APRS_sendPkt(_packet_buffer, _packet_length);
		setPTT(OFF);

		Serial.print(F("packet_buffer='"));
		Serial.print(_packet_buffer);
		Serial.println(F("'"));
		Serial.print(F("packet_length="));
		Serial.println(this->_packet_length);

		memset(_packet_buffer,0,sizeof(_packet_buffer));
		_packet_length=0;
	}


	void setBit(uint8_t bit, bool state){
		if (bit - 1 < 8) {
			_bits[bit] = (state ? '1' : '0');
		}
	}

	bool getBit(uint8_t bit){
		if (bit - 1 < 8) {
			return (_bits[bit] == '1');
		}
		return false;
	}

	void readTemperatureSensors(){

		  Serial.print(F("Requesting temperatures..."));
		_sensors->requestTemperatures();
		  Serial.println(F("DONE"));
//		  Serial.print(F("Temperature for the device 1 (index 0) is: "));
//		  Serial.println(sensors.getTempCByIndex(0)); // onboard
//		  Serial.println(sensors.getTempCByIndex(1)); // ant laido


	}
	void readBatteryVoltage(){
		// read ADC channel, calculate value and store it to class attribute
		// Jei reference voltage: 5.20V  daliklis: + 3k --- 750R --- (-)
		// max adc reiksme = 1024 prie 26V
		uint16_t adcValue = analogRead(VOLTAGE_ADC_PIN);
		Serial.print(F("adcValue="));
		Serial.println(adcValue);
		this->_battery_voltage = ((double) (adcValue * _mbMaxVoltage) / 1024);
		/*Parodo baterijos itampa serial porte, BET, itampa skaiciuojama analog reference atzvilgiu, kas pas mus yra maitinimo itampa.
		 * Kai modulis maitinasi is baterijos per itampos stabilizatoriu, tai analog reference = 3.2V, bet jei prisijungiam per USB
		 * tai itampa gaunasi 5V. Rezultate _battery_voltage reiksme bus skirtinga. Darbiniam rezime telemetrijos pakete viskas turetu eiti.
		 * Norint serial porte matyti teisinga reiksme, reikia pakeisti MB_ADC_VOLTAGE is 3.2 i 5.0
		 */
		Serial.println(F("Battery Voltage:"));
		Serial.println(this->_battery_voltage);
	}

	void setup();
	void loop();

};

void APRSTelemetry::setup(){
	Serial.println(F("APRSTelemetry::setup()\nInitializing temp. sensors"));

	this->_oneWire = new OneWire(ONE_WIRE_BUS);
	this->_sensors = new DallasTemperature(this->_oneWire);

	_sensors->begin();
	_sensors->setResolution(9); // zemesne rezoliucija - greiciau nuskaito (9 bitai - puses laipsnio tikslumu)


}

void APRSTelemetry::loop(){
	unsigned int seconds = (millis() / 1000);

	if (seconds - this->_ts_read_sensors > 3){
		// read temperature sensors
		this->readTemperatureSensors();
		this->readBatteryVoltage();

		this->updateTemperatures(_sensors->getTempCByIndex(0), _sensors->getTempCByIndex(1));
		this->updateBatteryVoltage();
//			telemetrija.updateTemperatures(sensors.getTempCByIndex(0), sensors.getTempCByIndex(1));
		this->_ts_read_sensors = seconds;

	}

	if (seconds - this->_ts_telemetry_packet > TELEMETRY_PACKET_INTERVAL){
		this->generateTelemetryPacket();
		this->sendTelemetryPacket();
		this->_ts_telemetry_packet = seconds;
	}

	if (seconds - this->_ts_packet_to_send > 45) {
		switch (_packet_to_send) {
		case 0:
			this->generateUnitsPacket();
			break;
		case 1:
			this->generateParametersPacket();
			break;
		case 2:
			this->generateEQNSPacket();
			break;

		}
		++this->_packet_to_send %= 3;
		this->sendTelemetryPacket();
		this->_ts_packet_to_send = seconds;
	}
}


struct SUptime {
	uint16_t uptime;
	uint16_t days;
	uint16_t  hours;
	uint16_t  mins;
	uint16_t  secs;
};

struct SAPRSLocation{
	char latitude[9]; // 8 + null
	char longitude[10]; // 9 + null
};

SAPRSLocation aprsLocation;
SUptime SYSUptime;
TinyGPSPlus gps;
APRSTelemetry telemetrija;


char strBuffer[40];		// buferis char operacijoms

uint32_t last_timestamp, timestamp = 0;
uint32_t cMillis, lMillis = 0;

// funkcija, kuri priima ieinanti paketa, kadangi mes tik transliuojam
// tai si funkcija tuscia.
void aprs_msg_callback(struct AX25Msg *msg) {
}

void updateSysUptime(const uint32_t& tstamp){
	SYSUptime.uptime =  tstamp;
    SYSUptime.days   =  tstamp / 86400;
    SYSUptime.hours  = (tstamp / 3600 ) % 24;
    SYSUptime.mins   = (tstamp / 60   ) % 60;
    SYSUptime.secs   =  tstamp % 60;
}

volatile uint32_t newlines = 0UL;

void setup() {
	updateSysUptime(0);
	gpsToAprs(0,0);
	// Greitis pagal GPS imtuva. RX pin - imtuvas, TX - debug output (USB)
	Serial.begin(SERIAL_BAUDRATE);

	pinMode(13, OUTPUT);	//LED
	digitalWrite(13, LOW);
	pinMode(PTT_PIN, OUTPUT);		//PTT
	digitalWrite(PTT_PIN, OFF);

	// Initialise APRS library - This starts the modem
	APRS_init(ADC_REFERENCE, OPEN_SQUELCH);

	// Callsign & SSID
	APRS_setCallsign(APRS_CALLSIGN, APRS_SSID);

	// You can define preamble and tail like this:
	 APRS_setPreamble(APRS_PREAMBLE);
	 APRS_setTail(70);

	// Balionas - "O", zmogus - "[", masina - ">"
	// APRS_setSymbol('O');   // balionas "O", jei pagrindine simboliu lentele
	APRS_setSymbol('[');	// zmogus - "["
	Serial.println(F("*** Startup ***"));
	Serial.println(F("HAB LKB"));
	Serial.println(F("Versija " VERSION));
	telemetrija.setup();


}

void locationUpdate(){
	/*
	 * Cia paruosiam lokacijos paketa, sukuriam komentara ir istransliuojam
	 */

	setPTT(ON);

	// http://www.earthpoint.us/Convert.aspx
	// GPS duoda Laipsniai.laipsnio dalys
    // Location: 54,705383,25.252481  Date/Time: 9/9/2018 15:31:43.00
	// APRS reikia: Laipsniai Minutes.minutes dalys (ne sekundes)
	// 5442.30N lon 02515.19E

	APRS_setLat(aprsLocation.latitude);
	APRS_setLon(aprsLocation.longitude);

	int count = sprintf(strBuffer,"LKB Up: %u d. %u h.", SYSUptime.days, SYSUptime.hours); // "LKB Up: 1 d. 15 h.";
//	Serial.println(strBuffer);

	APRS_sendLoc(strBuffer, count);
//	APRS_sendLoc(strBuffer, strlen(strBuffer));
	setPTT(OFF);
}

/*
 * PTT valdom rankiniu budu, kadangi
 * 1) automatinis valdymas mums netinka, nes PTT siam moduliui reikia paspausti ir palaikyti bent puse sekundes,
 *    kad issiustu visa paketa
 * 2) reikalingas active LOW PTT lygis.
 */
void setPTT(int state){
	digitalWrite(PTT_PIN, state);
	if (state == ON) {
		delay(DELAY_AFTER_PTT_ON);
	}
}

void blink(int d=25){
	// ciklo laikas milisekundemis = d * 2
		digitalWrite(13, HIGH);
		delay(d);
		digitalWrite(13, LOW);
		delay(d);
}

void gpsToAprs(double lat, double lon){
	// TODO galima patobulinti, kad rasytu i paduota, o ne globalia struktura
	char h_lat;
	char h_lon;

	// nusistatom pusrutulius, atitinkamai verciam is neigiamu laipsniu i teigiamus
	if (lat >=0){
		h_lat='N';
	} else {
		h_lat='S';
		lat=-lat;
	}

	if (lon >=0){
		h_lon='E';
	} else {
		h_lon='W';
		lon=-lon;
	}

	int deg_lat = (int) lat;// konversija i int panaikina skaiciu po kablelio.
	int deg_lon = (int) lon;

	double f = lat * 60;
	int lat_min = (uint32_t) f % 60;	 // minutes
	f *= 100;
	int lat_min_p = (uint32_t) f % 100; // minuciu skaicius po kablelio

	f = lon * 60;
	int lon_min = (uint32_t) f % 60;	 // minutes
	f *= 100;
	int lon_min_p = (uint32_t) f % 100; // minuciu skaicius po kablelio

	// rasom i tarpini buferi, kadangi kitaip nesikompiliuoja kodas
	snprintf_P(strBuffer, sizeof(strBuffer), PSTR("%02d%02d.%02d%c"), deg_lat,
			lat_min, lat_min_p, h_lat);
	strncpy(aprsLocation.latitude, strBuffer, sizeof(aprsLocation.latitude));

	snprintf_P(strBuffer, sizeof(strBuffer), PSTR("%03d%02d.%02d%c"), deg_lon,
			lon_min, lon_min_p, h_lon);
	strncpy(aprsLocation.longitude, strBuffer, sizeof(aprsLocation.longitude));

	// segfault :/
//	snprintf_P(aprsLocation.latitude, sizeof(aprsLocation.latitude),
//			PSTR("%02d%02d.%02d%01s"), deg_lat, lat_min, lat_min_p,h_lat
//			);
//	snprintf_P(aprsLocation.longitude, sizeof(aprsLocation.longitude),
//			PSTR("%03d%02d.%02d%01s"), deg_lon, lon_min, lon_min_p,h_lon
//			);
}

void displayInfo(){
	// debug output'as i serial porta
	Serial.print(F("Location: "));
	if (gps.location.isValid()) {
		Serial.print(gps.location.lat(), 6);
		Serial.print(F(","));
		Serial.print(gps.location.lng(), 6);
	} else {
		Serial.print(F("INVALID"));
	}

	Serial.print(F("  Date/Time: "));
	if (gps.date.isValid()) {
		Serial.print(gps.date.month());
		Serial.print(F("/"));
		Serial.print(gps.date.day());
		Serial.print(F("/"));
		Serial.print(gps.date.year());
	} else {
		Serial.print(F("INVALID"));
	}

	  Serial.print(F(" "));
	if (gps.time.isValid()) {
		if (gps.time.hour() < 10)
			Serial.print(F("0"));
		Serial.print(gps.time.hour());
		Serial.print(F(":"));
		if (gps.time.minute() < 10)
			Serial.print(F("0"));
		Serial.print(gps.time.minute());
		Serial.print(F(":"));
		if (gps.time.second() < 10)
			Serial.print(F("0"));
		Serial.print(gps.time.second());
		Serial.print(F("."));
		if (gps.time.centisecond() < 10)
			Serial.print(F("0"));
		Serial.print(gps.time.centisecond());
	} else {
		Serial.print(F("INVALID"));
	}
	Serial.println();
}



/*
 * Kvieciamas kas sekunde, nors negarantuotai, kad kas kiekviena sekunde. Kvieciama is main loop()
 */
void timerEverySecond(){
	updateSysUptime(timestamp);
	blink();
	if (gps.location.isValid()) {
		blink(50);
	}
//	readSensors();

	if ((timestamp % 3) == 0) {

		Serial.print(String(aprsLocation.latitude) + '/' + String(aprsLocation.longitude)+" ");
		displayInfo();

	}
	if ((timestamp % 10) == 0) {
		Serial.println("Up: " + String(SYSUptime.uptime));
	}
	if ((timestamp % PACKET_INTERVAL) == 0) {
		// sitas isValid() nevisai geras budas, nes kartais gali issiusti neteisinga arba sena informacija
		if (gps.location.isValid()) {
			Serial.println(F("Sending aprs location packet"));
			locationUpdate();
		}
	}

}



// The loop function is called in an endless loop
void loop() {
	timestamp = millis()/1000;

	// read GPS info from serial port if available
	while (Serial.available()){
	    if (gps.encode(Serial.read())){
	    	if (gps.location.isValid()) {
	    		gpsToAprs(gps.location.lat(), gps.location.lng());
	    	}
	    }
	}

	telemetrija.loop();		// do telemetry stuff - generate and send packets when needed

	if (timestamp != last_timestamp) timerEverySecond();
	last_timestamp = timestamp;
	delay(100);
}
